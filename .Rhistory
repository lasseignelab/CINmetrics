plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
max_circum <- max(dataset$circumference)
p1 <- ggplot(data=dataset, aes(x=age, y=circumference, colour=Tree)) +
geom_point()
return(min_circum, max_circum, p1)
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
max_circum <- max(dataset$circumference)
p1 <- ggplot(data=dataset, aes(x=age, y=circumference, colour=Tree)) +
geom_point()
return(list(min_circum, max_circum, p1))
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circuference)
max_circum <- max(dataset$circumference)
p1 <- ggplot(data=dataset, aes(x=age, y=circumference, colour=Tree)) +
geom_point()
return(list(min_circum, max_circum, p1))
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
max_circum <- max(dataset$circumference)
p1 <- ggplot(data=dataset, aes(x=age, y=max_circumference, colour=Tree)) +
geom_point()
return(list(min_circum, max_circum, p1))
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
max_circum <- max(dataset$circumference)
p1 <- ggplot(data=dataset, aes(x=age, y=max_circum, colour=Tree)) +
geom_point()
return(list(min_circum, max_circum, p1))
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
max_circum <- max(dataset$circumerence)
p1 <- ggplot(data=dataset, aes(x=age, y=max_circum, colour=Tree)) +
geom_point()
return(list(min_circum, max_circum, p1))
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
max_circum <- max(dataset$circumerence)
p1 <- ggplot(data=dataset, aes(x=age, y=max_circum, colour=Tree)) +
geom_point()
return(p1)
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
print(min_cirum)
max_circum <- max(dataset$circumerence)
print(max_circum)
p1 <- ggplot(data=dataset, aes(x=age, y=max_circum, colour=Tree)) +
geom_point()
return(p1)
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
print(min_circum)
max_circum <- max(dataset$circumerence)
print(max_circum)
p1 <- ggplot(data=dataset, aes(x=age, y=max_circum, colour=Tree)) +
geom_point()
return(p1)
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
max_circum <- max(dataset$circumerence)
p1 <- ggplot(data=dataset, aes(x=age, y=max_circum, colour=Tree)) +
geom_point()
return(p1)
}
plot_circum(Orange)
plot_circum <- function(dataset){
min_circum <- min(dataset$circumference)
print(min_circum)
max_circum <- max(dataset$circumerence)
print(max_circum)
p1 <- ggplot(data=dataset, aes(x=age, y=max_circum, colour=Tree)) +
geom_point()
return(p1)
}
plot_circum(Orange)
pa <- 0.5
pa * log(pa)
pa * log2(pa)
install.packages("UCSCXenaTools")
library(UCSCXenaTools)
data("XenaData")
head(XenaData)
View(XenaData)
KidsFirstQuery <- XenaGenerate(subset = XenaHostNames=='kidsfirstHub')) %>%
KidsFirstQuery <- XenaGenerate(subset = XenaHostNames=='kidsfirstHub') %>%
XenaFilter(filterDatasets = "counts")
eg_df <- data.frame(exp_id = c("uni1", "uni2", "uni3", "uni4"), gene_id = c("ENSMUSG00000011171", "ENSMUSG00000011171", "ENSMUSG00000011172", "ENSMUSG00000011172"), tpm = c(1230, 1543, 200, 300), stringsAsFactors = FALSE)
library(dplyr)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm))
eg_df <- data.frame(mice_id = c("uni1", "uni2", "uni1", "uni2"), gene_id = c("ENSMUSG00000011171", "ENSMUSG00000011171", "ENSMUSG00000011172", "ENSMUSG00000011172"), tpm = c(1230, 1543, 200, 300), stringsAsFactors = FALSE)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm))
eg_df %>% group_by(gene_id, mice_id) %>% mutate(avg_tpm = mean(tpm))
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm))
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm), .keep = "none")
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm)) %>% unique(gene_id)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm)) %>% unique(.$gene_id)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm)) %>% distinct(gene_id)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm), .keep = "all") %>% distinct(gene_id, .keep_all = TRUE)
eg_df <- data.frame(mice_id = c("uni1", "uni2", "uni1", "uni2"), gene_id = c("ENSMUSG00000011171", "ENSMUSG00000011171", "ENSMUSG00000011172", "ENSMUSG00000011172"), tpm = c(1230, 1543, 200, 300), stringsAsFactors = FALSE)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm), .keep = "all") %>% distinct(gene_id, .keep_all = TRUE)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm)) %>% distinct(gene_id, .keep_all = TRUE)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm), .keep = "all") %>% distinct(gene_id, .keep_all = TRUE)
library(tibble)
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm), .keep = "all") %>% distinct(gene_id, .keep_all = TRUE) %>% column_to_rownames(var = "gene_id")
eg_df %>% group_by(gene_id) %>% mutate(avg_tpm = mean(tpm), .keep = "all") %>% distinct(gene_id, .keep_all = TRUE) %>% column_to_rownames(var = "gene_id") %>% as.matrix()
2 + 3
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
summary(cars)
BiocManager::install("BgeeDB")
library(BgeeDB)
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("tidyr")
library(BgeeDB)
#for data wrangling
library(dplyr)
library(tibble)
bgee_mouse <- Bgee$new(species= "Mus_musculus", dataType = "rna_seq")
mouse_anno <- getAnnotation(bgee_mouse)
bgee_mousedata <- BgeeDB::getData(bgee_mouse, experimentId = "ERP104395")
bgee_mousedata <- BgeeDB::getData(bgee_mouse, experimentId = "ERP104395")
bgee_mouse <- Bgee$new(species= "Mus_musculus", dataType = "rna_seq")
mouse_anno <- getAnnotation(bgee_mouse)
bgee_mousedata <- BgeeDB::getData(bgee_mouse, experimentId = "ERP104395")
mouse_anno$sample.annotation$Experiment.ID
bgee_mousedata <- BgeeDB::getData(bgee_mouse, experimentId = "GSE30617")
#from Bgee page, loads a mapping from genes to anatomical structures based on calls of expression in anatomical structures. It also loads the structure of the anatomical ontology
top_mouse_anat <- loadTopAnatData(bgee_mouse)
#retrieving all genes with data in Bgee
all_mouse_genes <- unique(row.names(top_mouse_anat$gene2anatomy))
gene_list_mouse <- factor(as.integer(unique(all_mouse_genes) %in% annotations_mouse$ENSEMBL))
#loading in mouse organism annotation
BiocManager::install("org.Mm.eg.db")
library(AnnotationDbi)
#mouse organism annotation
org.Mm.eg.db
keys_mouse <- keys(org.Mm.eg.db, keytype = "ENSEMBL")
library(org.Mm.eg.db)
#mouse organism annotation
org.Mm.eg.db
keys_mouse <- keys(org.Mm.eg.db, keytype = "ENSEMBL")
cols_mouse <- c("ENTREZID", "SYMBOL")
select(org.Mm.eg.db, keys = keys_mouse, columns = cols_mouse, keytype = "ENSEMBL")
GPCR_Yoder <- read.csv("/Users/vishal/Desktop/GPCRTargets.csv", header = TRUE, sep = ",")
head(GPCR_Yoder)
#needs to be character vector for "keys"
entrez_mouse_char <- as.character(GPCR_Yoder$Mouse.Entrez.Gene)
# Return the Ensembl IDs for a set of genes
annotations_mouse <- AnnotationDbi::select(org.Mm.eg.db, keys = entrez_mouse_char, columns = c("SYMBOL", "ENSEMBL"),keytype = "ENTREZID")
# Determine the indices for the non-NA genes
non_na_mouse <- which(is.na(annotations_mouse$SYMBOL) == FALSE)
# Return only the genes with annotations using indices
annotations_mouse <- annotations_mouse[non_na_idx, ]
# Return only the genes with annotations using indices
annotations_mouse <- annotations_mouse[non_na_mouse, ]
# Determine the indices for the non-duplicated genes
non_dups_mouse <- which(duplicated(annotations_mouse$SYMBOL) == FALSE)
# Return only the non-duplicated genes using indices
annotations_mouse <- annotations_mouse[non_dups_mouse, ]
GPCR_mouse_genes <- annotations_mouse$ENSEMBL
gene_list_mouse <- factor(as.integer(unique(all_mouse_genes) %in% annotations_mouse$ENSEMBL))
names(gene_list_mouse) <- unique(all_mouse_genes)
#RNAseq data for just the GPCR genes
mouse_GPCR_rnaseq <- bgee_mousedata[bgee_mousedata$Gene.ID %in% annotations_mouse$ENSEMBL, ]
#subset for only gene id, tissue, and TPM
mouse_subset <- subset(mouse_GPCR_rnaseq[,c(4,6,12)])
#subset for just kidney
mouse_kidney <- mouse_subset[ which(mouse_subset$Anatomical.entity.name=="\"adult mammalian kidney\""), ]
View(mouse_kidney)
View(mouse_subset)
bgee_mousedata <- BgeeDB::getData(bgee_mouse, experimentId = "ERP104395")
#subset for just kidney
mouse_kidney <- mouse_subset[ which(mouse_subset$Anatomical.entity.name=="\"heart\""), ]
#subset for just kidney
mouse_kidney <- mouse_subset[ which(mouse_subset$Anatomical.entity.name=="heart"), ]
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_kidney %>% group_by(Gene.ID) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) %>% column_to_rownames(var = "Gene.ID") %>% as.matrix()
View(mouse_avg_kidney)
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_kidney %>% group_by(Gene.ID) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) %>% column_to_rownames(var = "Gene.ID") %>% select(avg_tpm) %>% as.matrix()
mouse_avg_kidney_subset <- mouse_avg_kidney[,c(2,3)]
#testing out, do TPM's need to be normalized further before calculating distance an dclustering?
mouse_dist <- dist(mouse_avg_kidney , method = "euclidean")
mouse_hclust <- hclust(mouse_dist, method = "average")
mouse_hclust_plot <- plot(mouse_hclust)
mouse_heatmap <- heatmap(mouse_dist)
View(mouse_GPCR_rnaseq)
View(mouse_subset)
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) %>% column_to_rownames(var = "Gene.ID") %>% select(avg_tpm) %>% as.matrix()
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) %>% column_to_rownames(var = "Gene.ID") %>% select(Anatomical.entity.name, avg_tpm) %>% as.matrix()
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID, Anatomical.entity.name) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) %>% column_to_rownames(var = "Gene.ID") %>% select(Anatomical.entity.name, avg_tpm) %>% as.matrix()
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID, Anatomical.entity.name) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) #%>% column_to_rownames(var = "Gene.ID") %>% select(Anatomical.entity.name, avg_tpm) %>% as.matrix()
13.552072 + 42.461259 + 6.274655 + 9.694251 + 13.223776 + 9.910453
(13.552072 + 42.461259 + 6.274655 + 9.694251 + 13.223776 + 9.910453)/6
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID, Anatomical.entity.name) %>% mutate(avg_tpm = mean(TPM), .keep = "all") #%>% distinct(Gene.ID, .keep_all = TRUE) #%>% column_to_rownames(var = "Gene.ID") %>% select(Anatomical.entity.name, avg_tpm) %>% as.matrix()
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID, Anatomical.entity.name) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) #%>% column_to_rownames(var = "Gene.ID") %>% select(Anatomical.entity.name, avg_tpm) %>% as.matrix()
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID, Anatomical.entity.name) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) %>% dcast(.,Gene.ID ~ Anatomical.entity.name, value.var="avg_tpm")
#subset for just kidney
#mouse_kidney <- mouse_subset[ which(mouse_subset$Anatomical.entity.name=="heart"), ]
library(reshape2)
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID, Anatomical.entity.name) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) %>% dcast(.,Gene.ID ~ Anatomical.entity.name, value.var="avg_tpm")
#average gene expression from different mice, code from Vishal (uses dplyr and tibble)
mouse_avg_kidney <- mouse_subset %>% group_by(Gene.ID, Anatomical.entity.name) %>% mutate(avg_tpm = mean(TPM), .keep = "all") %>% distinct(Gene.ID, .keep_all = TRUE) %>% dcast(.,Gene.ID ~ Anatomical.entity.name, value.var="avg_tpm") %>% column_to_rownames(var = "Gene.ID") %>% as.matrix()
#testing out, do TPM's need to be normalized further before calculating distance an dclustering?
mouse_dist <- dist(mouse_avg_kidney , method = "euclidean")
mouse_heatmap <- heatmap(mouse_dist)
head(mouse_dist)
mouse_heatmap <- heatmap(as.matrix(mouse_dist))
library(FactoMineR)
data(wine)
res <- MFA(wine, group=c(2,5,3,10,9,2), type=c("n",rep("s",5)),
ncp=5, name.group=c("orig","olf","vis","olfag","gust","ens"),
num.group.sup=c(1,6))
res <- MFA(wine, group=c(2,5,3,10,9,2), type=c("n",rep("s",5)),
ncp=5, name.group=c("orig","olf","vis","olfag","gust","ens"),
num.group.sup=c(1,6))
plot(res)
data (poison)
res <- MCA (poison[,3:8],excl=c(1,3))
data (poison)
res <- MCA (poison[,3:8],excl=c(1,3), graph = FALSE)
plot(res)
res.pca <- PCA(poison[,3:8], graph = FALSE)
res.pca <- PCA(poison, graph = FALSE)
data("decathlon")
res.pca <- PCA(decathlon, quanti.sup = 11:12, quali.sup=13, graph = FALSE)
plot(res.pca)
plot(res.mca)
res.mca <- MCA (poison[,3:8],excl=c(1,3), graph = FALSE)
plot(res.mca)
dog <- list(breed="GSD", coat="black and tan", size="large")
class(dog) <- append(class(dog),"Breed Type")
dog
dog <- list(breed="GSD", coat="black and tan", size="large")
class(dog) <- append(class(dog),"BreedType")
dog
GetBreed <- function(x){
UseMethod("GetBreed",x)
}
GetBreed.BreedType <- function(x)
{
return(x$breed)
}
GetBreed(dog)
GetBreed.Coat <- function(x)
{
return(x$coat)
}
GetBreed(dog)
GetBreed.Coat(dog)
dog
plot(res.pca)
library(Seurat)
library(SummarizedExperiment)
dog
GetBreed(dog)
plot(res.mca)
plot(res.pca)
View(annotations_mouse)
36*5
186+258
(19*2) + 93
(56*2)+19
library(TCGAbiolinks)
query.maskCNV.hg39.BRCA <- GDCquery(project = "TCGA-BRCA",
data.category = "Copy Number Variation",
data.type = "Masked Copy Number Segment", legacy=FALSE)
maskCNV.BRCA <- GDCprepare(query = query.maskCNV.hg39.BRCA, summarizedExperiment = FALSE)
maskCNV.BRCA <- data.frame(maskCNV.BRCA, stringsAsFactors = FALSE)
sam_id <- unique(maskCNV.BRCA$Sample)
#cnv <- maskCNV.BRCA$Segment_Mean
tai.test <- tai(cnvData = maskCNV.BRCA)
#' countingBaseSegments
#' Function for counting base segments
#' The Base Segment calculation takes all the CNV data for a single patient and first filters it for a segmentation mean of > 0.2 and, if specified, the minimum number of probes
#' covering that area. Then, it calculates the sums of the lengths of each segment for a particular patient and outputs that.
#' @param cnvData dataframe containing following columns: Sample, Start, End, Num_Probes, Segment_Mean
#' @param segmentMean numerical value for the minimum segment_mean cutoff/ threshold. Default is 0.2
#' @param numProbes Number of Probes
#' @return Number of Base segments
#' @export
countingBaseSegments <- function(cnvData, segmentMean = 0.2, numProbes = NA ){
unique_id <- unique(cnvData$Sample)
NumBases <- setNames(data.frame(matrix(ncol = 2, nrow = length(unique_id)), stringsAsFactors = FALSE),c("sample_id","base_segments"))
for (i in 1:length(unique_id)){
id <- unique_id[i]
exSample<-subset(cnvData, cnvData$Sample == id )
exSample<-subset(exSample, abs(exSample$Segment_Mean) >= segmentMean)
if (!is.na(numProbes)){
exSample<-subset(exSample, abs(exSample$Num_Probes) >= numProbes)
}
segSizes<-exSample$End - exSample$Start
count <- sum(segSizes)
NumBases$base_segments[i] <- count
NumBases$sample_id[i] <- id
}
return(NumBases)
}
base.seg.test <- countingBaseSegments(cnvData = maskCNV.BRCA)
View(base.seg.test)
##### countingBreakPoints ######
# The Break Point calculation takes all the CNV data for a single patient and first filters it for segmentation mean of > 0.2 and, if specified, the minimum number of probes
# covering that area. Then it counts the number of rows of data and multiplies it by 2. This represents the break points at the 5' and 3' ends of each segment.
# Input: Sample IDs, CNV data
# Output: Number of rows for each Sample ID * 2
#' @param cnvData dataframe containing following columns: Sample, Start, End, Num_Probes, Segment_Mean
#' @param segmentMean numerical value for the minimum segment_mean cutoff/ threshold. Default is 0.2
#' @param numProbes Number of Probes
#' @return Number of Break points for each unique sample
#' @export
countingBreakPoints <- function(cnvData, segmentMean = 0.2, numProbes = NA){
unique_id <- unique(cnvData$Sample)
NumBpt <- setNames(data.frame(matrix(ncol = 2, nrow = length(unique_id)), stringsAsFactors = FALSE),c("sample_id","break_points"))
for (i in 1:length(unique_id)){
id <- unique_id[i]
exSample<-subset(cnvData, cnvData$Sample == id )
exSample<-subset(exSample, abs(exSample$Segment_Mean) >= segmentMean)
if (!is.na(numProbes)){
exSample<-subset(exSample, abs(exSample$Num_Probes) >= numProbes)
}
number <- nrow(exSample) * 2 # Multiplied by 2 because of counting 5' and 3' breakpoints
NumBpt[i,] <- number
}
return(NumBpt)
}
break.points <- countingBreakPoints(cnvData = maskCNV.BRCA)
View(break.points)
##### countingBreakPoints ######
# The Break Point calculation takes all the CNV data for a single patient and first filters it for segmentation mean of > 0.2 and, if specified, the minimum number of probes
# covering that area. Then it counts the number of rows of data and multiplies it by 2. This represents the break points at the 5' and 3' ends of each segment.
# Input: Sample IDs, CNV data
# Output: Number of rows for each Sample ID * 2
#' @param cnvData dataframe containing following columns: Sample, Start, End, Num_Probes, Segment_Mean
#' @param segmentMean numerical value for the minimum segment_mean cutoff/ threshold. Default is 0.2
#' @param numProbes Number of Probes
#' @return Number of Break points for each unique sample
#' @export
countingBreakPoints <- function(cnvData, segmentMean = 0.2, numProbes = NA){
unique_id <- unique(cnvData$Sample)
NumBpt <- setNames(data.frame(matrix(ncol = 2, nrow = length(unique_id)), stringsAsFactors = FALSE),c("sample_id","break_points"))
for (i in 1:length(unique_id)){
id <- unique_id[i]
exSample<-subset(cnvData, cnvData$Sample == id )
exSample<-subset(exSample, abs(exSample$Segment_Mean) >= segmentMean)
if (!is.na(numProbes)){
exSample<-subset(exSample, abs(exSample$Num_Probes) >= numProbes)
}
number <- nrow(exSample) * 2 # Multiplied by 2 because of counting 5' and 3' breakpoints
NumBpt$break_points[i] <- number
NumBpt$sample_id[i] <- id
}
return(NumBpt)
}
break.points <- countingBreakPoints(cnvData = maskCNV.BRCA)
View(break.points)
#' Modified Total Aberration Index
#' Modified Total Aberration Index calculation takes the sum of lengths of each segment
#' times its segmentation mean for each sample and divides it by the sum of the
#' lengths of each sample.
#' @param cnvData dataframe containing following columns: Sample, Start, End, Num_Probes, Segment_Mean
#' @param segmentMean numerical value for the minimum segment_mean cutoff/ threshold. Default is 0.2
#' @param numProbes Number of Probes
#' @return Average of lengths weighted by segmentation mean for each unique sample
#' @export
mod.tai <- function(cnvData, segmentMean = 0, numProbes = NA ){
unique_id <- unique(cnvData$Sample)
tai.output <- setNames(data.frame(matrix(ncol = 2, nrow = length(unique_id)), stringsAsFactors = FALSE),c("sample_id","modified_tai"))
for (i in 1:length(ids)){
id <- unique_id[i]
subsetSample <- subset(cnvData, cnvData$Sample == id )
subsetSample <- subset(subsetSample, abs(subsetSample$Segment_Mean) >= segmentMean)
if (!is.na(numProbes)){
subsetSample<-subset(subsetSample, abs(subsetSample$Num_Probes) >= numProbes)
}
Length <- subsetSample$End - subsetSample$Start
num <- Length*subsetSample$Segment_Mean
den <- Length
tai.calc <- sum(sum(num)/sum(den))
tai.output$modified_tai[i] <- tai.calc
tai.output$sample_id[i] <- id
}
return(tai.output)
}
modified.tai <- modified.tai(cnvData = maskCNV.BRCA)
#' Modified Total Aberration Index
#' Modified Total Aberration Index calculation takes the sum of lengths of each segment
#' times its segmentation mean for each sample and divides it by the sum of the
#' lengths of each sample.
#' @param cnvData dataframe containing following columns: Sample, Start, End, Num_Probes, Segment_Mean
#' @param segmentMean numerical value for the minimum segment_mean cutoff/ threshold. Default is 0.2
#' @param numProbes Number of Probes
#' @return Average of lengths weighted by segmentation mean for each unique sample
#' @export
modified.tai <- function(cnvData, segmentMean = 0, numProbes = NA ){
unique_id <- unique(cnvData$Sample)
tai.output <- setNames(data.frame(matrix(ncol = 2, nrow = length(unique_id)), stringsAsFactors = FALSE),c("sample_id","modified_tai"))
for (i in 1:length(ids)){
id <- unique_id[i]
subsetSample <- subset(cnvData, cnvData$Sample == id )
subsetSample <- subset(subsetSample, abs(subsetSample$Segment_Mean) >= segmentMean)
if (!is.na(numProbes)){
subsetSample<-subset(subsetSample, abs(subsetSample$Num_Probes) >= numProbes)
}
Length <- subsetSample$End - subsetSample$Start
num <- Length*subsetSample$Segment_Mean
den <- Length
tai.calc <- sum(sum(num)/sum(den))
tai.output$modified_tai[i] <- tai.calc
tai.output$sample_id[i] <- id
}
return(tai.output)
}
modified.tai <- modified.tai(cnvData = maskCNV.BRCA)
#' Modified Total Aberration Index
#' Modified Total Aberration Index calculation takes the sum of lengths of each segment
#' times its segmentation mean for each sample and divides it by the sum of the
#' lengths of each sample.
#' @param cnvData dataframe containing following columns: Sample, Start, End, Num_Probes, Segment_Mean
#' @param segmentMean numerical value for the minimum segment_mean cutoff/ threshold. Default is 0.2
#' @param numProbes Number of Probes
#' @return Average of lengths weighted by segmentation mean for each unique sample
#' @export
modified.tai <- function(cnvData, segmentMean = 0, numProbes = NA ){
unique_id <- unique(cnvData$Sample)
tai.output <- setNames(data.frame(matrix(ncol = 2, nrow = length(unique_id)), stringsAsFactors = FALSE),c("sample_id","modified_tai"))
for (i in 1:length(unique_id)){
id <- unique_id[i]
subsetSample <- subset(cnvData, cnvData$Sample == id )
subsetSample <- subset(subsetSample, abs(subsetSample$Segment_Mean) >= segmentMean)
if (!is.na(numProbes)){
subsetSample<-subset(subsetSample, abs(subsetSample$Num_Probes) >= numProbes)
}
Length <- subsetSample$End - subsetSample$Start
num <- Length*subsetSample$Segment_Mean
den <- Length
tai.calc <- sum(sum(num)/sum(den))
tai.output$modified_tai[i] <- tai.calc
tai.output$sample_id[i] <- id
}
return(tai.output)
}
modified.tai <- modified.tai(cnvData = maskCNV.BRCA)
#' Modified Total Aberration Index
#' Modified Total Aberration Index calculation takes the sum of lengths of each segment
#' times its segmentation mean for each sample and divides it by the sum of the
#' lengths of each sample.
#' @param cnvData dataframe containing following columns: Sample, Start, End, Num_Probes, Segment_Mean
#' @param segmentMean numerical value for the minimum segment_mean cutoff/ threshold. Default is 0.2
#' @param numProbes Number of Probes
#' @return Average of lengths weighted by segmentation mean for each unique sample
#' @export
taiModified <- function(cnvData, segmentMean = 0, numProbes = NA ){
unique_id <- unique(cnvData$Sample)
tai.output <- setNames(data.frame(matrix(ncol = 2, nrow = length(unique_id)), stringsAsFactors = FALSE),c("sample_id","modified_tai"))
for (i in 1:length(unique_id)){
id <- unique_id[i]
subsetSample <- subset(cnvData, cnvData$Sample == id )
subsetSample <- subset(subsetSample, abs(subsetSample$Segment_Mean) >= segmentMean)
if (!is.na(numProbes)){
subsetSample<-subset(subsetSample, abs(subsetSample$Num_Probes) >= numProbes)
}
Length <- subsetSample$End - subsetSample$Start
num <- Length*subsetSample$Segment_Mean
den <- Length
tai.calc <- sum(sum(num)/sum(den))
tai.output$modified_tai[i] <- tai.calc
tai.output$sample_id[i] <- id
}
return(tai.output)
}
modified.tai <- taiModified(cnvData = maskCNV.BRCA)
View(modified.tai)
library(devtools)
pkgload::load_all()
rm(list = c("countingBaseSegments", "countingBreakPoints", "mod.tai", "taiModified"))
pkgload::load_all()
#cnv <- maskCNV.BRCA$Segment_Mean
tai.test <- tai(cnvData = maskCNV.BRCA)
tai.test1 <- CINmetrics::tai.original(ids = sam_id, maskCNV.BRCA)
View(tai.test1)
